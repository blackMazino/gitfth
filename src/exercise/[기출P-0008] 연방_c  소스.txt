#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

#define MAXN 100005
#define MAXQ 200005

int T, N, M, t, i, Q, x,y;
int q, a, b;
int d1, d2;
int p[MAXN], cnt[MAXQ], g[MAXN][3], que[MAXQ][3];


int find(int n){

	if(p[n] <0) return n;

	p[n] = find(p[n]);
	return p[n];

}

void merge(int a, int b){
	
	x = find(a);
	y = find(b);
	if(x==y){
		//싸이클이 생겼을 때 뭔가 처리를 해야 할 거 같............지만 안할꺼야 ㅋ
		return;
	}
	p[y] = x;

}


int main(){

	//freopen("test_input.txt", "r", stdin);
	setbuf(stdout, NULL);

	scanf("%d", &T);

	for(t=1; t<=T; t++){

		//초기화 시작
		for(i=1; i<MAXN; i++){
			g[i][0]=g[i][1]=g[i][2] = 0;
			//p[i] = 0;
		}
		for(i=0; i<MAXQ; i++){
			que[i][0] = que[i][1] = que[i][2] = 0;
			cnt[i] = 0;
		}
		//초기화 끝

	    scanf("%d %d", &N, &M);
		for(i=1; i<=N; i++){
			p[i] = -1;
		}


		for(i=1; i<=M; i++){
			scanf("%d %d", &g[i][0],  &g[i][1]); // 간선정보 쭉 쌓음
		}

	    scanf("%d", &Q); //질의갯수 받아서

		for(i=1; i<=Q; i++){
			scanf("%d", &que[i][0]);

			if(que[i][0]==1){
				scanf("%d", &que[i][1]); // 끊을 배열을 받아놓고
				g[que[i][1]][2] = 1; // 끊었다고 표시
			}
			else{
				scanf("%d %d", &que[i][1], &que[i][2]); //같은 연방인지 검증할 자료는 일단 쌓아둠
			}


		}


		//다음 작업은 g배열을 돌면서 끊은거 빼놓고 나머지를 union연산
		for(i=1; i<=M; i++){
			if(g[i][2] != 1)
				merge(g[i][0], g[i][1]);
		}

		//그래프가 1차적으로 완성되었으면 que배열을 돌면서 잇고 계산해서 심음.. 
		int c =  0;
		for(i=Q; i>0; i--){
			if(que[i][0] == 1){ //끊은 애를 union 연산 
				merge(g[que[i][1]][0], g[que[i][1]][1]);
			}else{ //연결되어있는지 확인
				d1 = find(que[i][1]);
				d2 = find(que[i][2]);
				if(d1 == d2) {
					cnt[c] = 1;
					c++;
				}else{
					cnt[c] = 0;
					c++;
				}
			}
		}


		printf("#%d ",t); //정답 출력
		
		for(i=c-1; i>=0; i--){
	
			printf("%d", cnt[i]);

		}

		printf("\n");
	
	}

}